> **导航：**
> 
> [【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289 "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**

[一、JVM基本介绍](#%E4%B8%80%E3%80%81JVM%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D)

[二、JVM内存模型](#%E4%BA%8C%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)

[2.0 概述](#2.0%20%E6%A6%82%E8%BF%B0)

[2.1 类加载子系统](#2.1%C2%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F)

[2.2 运行时数据区](#2.2%C2%A0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA)

[2.2.0 基本介绍](#2.2.0%C2%A0%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D)

[2.2.1 本地方法栈：由C语言实现](#2.2.1%C2%A0%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%9A%E7%94%B1C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0)

[2.2.2 Java方法栈（虚拟机栈）](#2.2.2%20Java%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%89)

[2.2.3 方法区](#2.2.3%C2%A0%E6%96%B9%E6%B3%95%E5%8C%BA)

[2.2.3.1 基本概念](#2.2.3.1%C2%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0) 

[2.2.3.2 实现方式：永久代和元空间](#2.2.3.2%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4)

[2.2.3.3 组成元素：类常量池、运行时常量池、字符串常量池](#2.2.3.3%20%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0%EF%BC%9A%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)

[2.2.4 堆](#2.2.4%C2%A0%E5%A0%86)

[2.2.5 程序计数器（PC寄存器）](#2.2.5%C2%A0%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89)

[2.3 执行引擎](#2.3%C2%A0%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E)

--

## 一、JVM基本介绍

我们经常说Java是一个跨平台的语言，因为它是运行在Java虚拟机上（JVM）的。

在Java程序的实际编译、运行过程中，编译器将Java源代码编译成字节码文件后，JVM将字节码翻译成特定平台的机器码运行程序。

实际上，Java是跨平台的，JVM不是跨平台的，我们在Linux、windows等系统中安装对应版本的JVM后，同一个Java代码在这些JVM上运行，从而起到跨平台的效果。

> **JDK、JRE、JVM、Java的区别：**
> 
> JVM是Java虚拟机，JRE是Java运行环境，JDK是个Java开发的工具包，Java是门编程语言。 
> 
> -   **JVM（Java Virtual Machine）：**是Java虚拟机，是Java程序运行的基础，它将Java程序编译后的字节码解释执行，并将其转换为机器码运行。
> -   **JRE（Java Runtime Environment）：**是Java运行环境，包括了JVM以及Java程序运行所需的类库等。
> -   **JDK：**Java开发工具包，包括了JRE以及用于Java开发的工具，如编译器（javac）、调试器（jdb）、打包工具（jar）等。
> 
> ![](https://i-blog.csdnimg.cn/blog_migrate/b30efff36625b1a2f062497a46811390.png)

## 二、JVM内存模型

### 2.0 概述

**JVM由三大部分组成：**类加载子系统、运行时数据区、执行引擎。

![](https://i-blog.csdnimg.cn/blog_migrate/b1ee6cdffc9900589cc892fbb9d13455.png)

### 2.1 **类加载子系统**

**类加载子系统：**通过类加载机制加载类的class文件，如果该类是第一次加载，会执行加载、验证、解析。只负责class文件的加载，至于是否可运行，则由执行引擎决定。

JVM中，类加载过程是在类加载子系统完成的。

**类加载过程：**加载 --> 链接（验证 --> 准备 --> 解析） --> 初始化

![](https://i-blog.csdnimg.cn/blog_migrate/e34e7a7784f825ff28aa376aac50b6c9.png)

> **类加载过程：**加载、链接（验证、准备、解析）、初始化。这个过程是在类加载子系统完成的。
> 
> **加载：**生成类的Class对象。
> 
> 1.  通过一个类的全限定名获取定义此类的二进制字节流（即编译时生成的类的class字节码文件）
> 2.  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。包括创建运行时常量池，将类常量池的部分符号引用放入运行时常量池。
> 3.  在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类各种数据的访问入口。注意类的class对象是运行时生成的，类的class字节码文件是编译时生成的。
> 
> **链接：**将类的二进制数据合并到JRE中。该过程分为以下3个阶段：
> 
> -   **验证：**确保代码符合JAVA虚拟机规范和安全约束。包括文件格式验证、元数据验证、字节码验证、符号引用验证。
>     -   **文件格式验证：**验证字节码文件是否符合规范。
>         -   **魔数：**是否魔数0xCAFEBABE开头
>         -   **版本号：**版本号是否在JVM兼容范围
>         -   **常量类型：**类常量池里常量类型是否合法
>         -   **索引值：**索引值是否指向不存在或不符合类型的常量。
>     -   **元数据验证：**元数据是字节码里类的全名、方法信息、字段信息、继承关系等。
>         -   **标识符：**验证类名接口名标识符有没有符合规范
>         -   **接口实现方法：**有没有实现接口的所有方法
>         -   **抽象类实现方法：**有没有实现抽象类的所有抽象方法
>         -   **final类：**是不是继承了final类。
>     -   **指令验证：**主要校验类的方法体，通过数据流和控制流分析，保证方法在运行时不会危害虚拟机安全。
>         -   **类型转换：**保证方法体中的类型转换是否有效。例如把某个类强转成没继承关系的类
>         -   **跳转指令：**保证跳转指令不会跳转到方法体以外的字节码指令上；
>         -   保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。
>     -   **符号引用验证：**确保后面解析阶段能正常执行。
>         -   **类全限定名地址：**验证类全限定名是否能找到对应的类字节码文件
>         -   **引用地址：**引用指向地址是否存在实例
>         -   **引用权限：**是否有权引用
> -   **准备：**为类变量（即static变量）分配内存并赋零值。
> -   **解析：**将方法区-运行时常量池内的符号引用（类的名字、成员名、标识符）转为直接引用（实际内存地址，不包含任何抽象信息，因此可以直接使用）。
> 
> **初始化：**类变量赋初值、执行静态语句块。

### 2.2 **运行时数据区**

#### **2.2.0 基本介绍**

**运行时数据区：**在程序运行时，存储程序的内容（例如字节码、对象、参数、返回值等）。

运行时数据区包括本地方法栈、虚拟机栈、方法区、堆、程序计数器。

在运行时数据区中，只有方法区和堆是各线程共享的进程内存区域，其他运行区都是每个线程可以独立拥有的。

**图示：**

![](https://i-blog.csdnimg.cn/blog_migrate/9af4f993672039215cab52cfec4a0f3e.png)

#### **2.2.1 本地方法栈：由C语言实现**

**本地方法栈：**存放本地方法调用过程中的栈帧。

本地方法栈用于管理本地方法的调用，本地方法是**C语言**写的**，**被编译为基于本机硬件和操作系统的程序。

> **注意：**不是所有虚拟机都支持本地方法栈，例如Hotspot虚拟机（HotSpot是Sun/OracleJDK和OpenJDK中的默认Java虚拟机）就是将本地方法栈和虚拟机栈合二为一。栈解决程序的运行问题，即程序如何执行、如何处理数据。

**栈帧：**栈帧是栈的元素，由三部分组成，即局部变量表（存方法参数和**局部变量**）、操作数栈（存方法执行过程中的中间结果，或者其他暂存数据）和帧数据区（存方法返回地址、线程引用等附加信息）。

#### **2.2.2 Java方法栈（虚拟机栈）**

存放Java方法调用过程中的栈帧。用于管理Java方法的调用。

Java方法是我们**开发时写的Java方法**。

![](https://i-blog.csdnimg.cn/blog_migrate/2f992c4962bbd84f2baf6f663e9f4bbb.png)

#### **2.2.3 方法区**

##### **2.2.3.1** 基本概念 

**方法区：**可以看作是一块独立于Java堆的内存空间，方法区是各线程共享的内存区域。

![](https://i-blog.csdnimg.cn/blog_migrate/7eea2c4723cd5cafe4f0b8fee7223325.png)

##### **2.2.3.2 实现方式：**永久代和元空间

方法区有两种实现方式，分别是：永久代和元空间。

**永久代：**属于JVM方法区的内存，用来存储**类的元数据**，如类名、方法信息、字段信息等一些静态的数据。

**永久代的特点：**

-   JDK7及之前方法区也叫永久代。
-   永久代的缺点是内存大小固定，容易出现oom问题。
-   可以通过-XX:PermSize设置永久代大小。永久代对象只能通过Major GC（又称Full GC）进行垃圾回收。

**元空间：**是Hotspot在JDK8引入的，用于取代永久代。

元空间属于本地内存，由操作系统直接管理，不再受JVM管理。

同时内存空间可以自动扩容，避免内存溢出。默认情况下元空间可以无限使用本地内存，也可以通过-XX:MetaspaceSize限制内存大小。

**方法区和永久代、元空间的关系：**方法区是一个抽象概念，永久代和元空间是方法区的实现方式。

##### **2.2.3.3 组成元素：类常量池、运行时常量池、字符串常量池**

**常量池：**就是一张表，JVM根据这张常量表找到要执行的类信息和方法信息

-   **类常量池：**是.class字节码文件中的资源仓库，主要存放字面量（表示字符串值和数值，例如字符串值"abc"、**final常量、静态变量**）和符号引用（类和接口的全限定名、字段名、方法名）。
-   **运行时常量池：**类加载的“加载”阶段会创建运行时常量池，统一存放各个类常量池去重后的符号引用。在类加载的“解析”阶段JVM会把运行时常量池的这些符号引用转为直接引用。类常量池。类常量池在字节码文件中的，运行时常量池在内存中。
-   **字符串常量池：**专门针对String类型设计的常量池。是当前应用程序里所有线程共享的，每个jvm只有一个字符串常量池。存储字符串对象的引用。在创建String对象时，JVM会先在字符串常量池寻找是否已存在相同字符串的引用，如果有的话就直接返回引用，没的话就在堆中创建一个对象，然后常量池保存这个引用并返回引用。

#### **2.2.4 堆**

**堆：**存放对象实例、**实例变量**、数组，包括新生代（伊甸园区、幸存区S0和S1）和老年代。

堆是垃圾收集器管理的内存区域。

堆解决的是数据存储的问题，即数据怎么放、放在哪儿。堆实际内存空间可以不连续，大小可以选择固定大小或可扩展，堆是各线程共享的内存区域。

> **堆的GC流程：**
> 
> 1.   首先，任何新对象都分配到 eden 空间。两个幸存者空间开始时都是空的。
> 2.  当 eden 空间填满时，将触发一个**Minor GC**(年轻代的垃圾回收，也称为Young GC)，删除所有未引用的对象，**大对象**（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年代。
> 3.  所有被引用的对象作为存活对象，将移动到第一个幸存者空间S0，并标记年龄为1，即经历过一次Minor GC。之后每经过一次Minor GC，年龄+1。GC分代年龄存储在对象头的Mark Word里。
> 4.  当 eden 空间再次被填满时，会执行第二次Minor GC，将Eden和S0区中所有垃圾对象清除，并将存活对象复制到S1并年龄加1，此时S0变为空。
> 5.  如此反复在S0和S1之间切换几次之后，还存活的**年龄等于15的对象**（JDK8默认15，JDK9默认7，-XX:InitialTenuringThreshold=7）在下一次Minor GC时将放到老年代中。 
> 6.  当老年代满了时会触发**Major GC**（也称为Full GC），Major GC 清理整个堆 – 包括年轻代和老年代。
> 
> ![](https://i-blog.csdnimg.cn/blog_migrate/f46c80dc389e4cdb92c8be4f692e92c1.png)

#### **2.2.5 程序计数器（PC寄存器）**

**程序计数器（PC寄存器）：**存放下一条字节码指令的地址，由执行引擎读取下一条字节码指令并转为本地机器指令进行执行。是程序控制流（分支、循环、跳转、线程恢复）的指示器，只有它不会抛出OutOfMemoryError。每个线程有自己独立的程序计数器，以便于线程在切换回来时能知道下一条指令是什么。程序计数器生命周期与线程一致。

![](https://i-blog.csdnimg.cn/blog_migrate/dfa57c08f30c2104bd8a7ac72c507bcd.png)

### 2.3 **执行引擎**

**执行引擎：**将字节码指令解释/编译为对应平台上的本地机器指令。充当了将高级语言翻译为机器语言的译者。

执行引擎在执行过程中需要执行什么样的字节码指令依赖于PC寄存器。每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。

指令可以分为字节码指令和本地机器指令。

-   **字节码指令（JVM指令）：**字节码文件中的指令，内部只包含一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息，不能够直接运行在操作系统之上。
-   **本地机器指令：**可以直接运行在操作系统之上。