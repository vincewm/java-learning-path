> **导航：**
> 
> [【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289?spm=1001.2014.3001.5501 "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**

[一、索引的分类与使用](#%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8)

[1.1 索引的分类](#1.1%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB)

[1.1.1. 普通索引](#1.1.1.%20%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95)

[1.1.2. 唯一索引](#1.1.2.%20%E5%94%AF%E4%B8%80%E6%80%A7%E7%B4%A2%E5%BC%95)

[1.1.3. 主键索引（唯一非空）](#1.1.3.%20%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%88%E5%94%AF%E4%B8%80%E9%9D%9E%E7%A9%BA%EF%BC%89)

[1.1.4. 单列索引](#1.1.4.%20%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95)

[1.1.5. 多列(组合、联合)索引](#1.1.5.%20%E5%A4%9A%E5%88%97%28%E7%BB%84%E5%90%88%E3%80%81%E8%81%94%E5%90%88%29%E7%B4%A2%E5%BC%95)

[1.1.6. 全文索引](#1.1.6.%20%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95)

[1.1.7. 空间索引（不常用）](#1.1.7.%20%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8D%E5%B8%B8%E7%94%A8%EF%BC%89)

[1.2 创建表的时候创建索引](#1.2%20%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95)

[1.2.1 约束字段会隐式自动创建索引](#1.2.1%20%E7%BA%A6%E6%9D%9F%E5%AD%97%E6%AE%B5%E4%BC%9A%E9%9A%90%E5%BC%8F%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95)

[1.2.1 显式、创建表的时候创建索引](#1.2.1%20%E6%98%BE%E5%BC%8F%E3%80%81%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95)

[1.3 在已经存在的表上创建索引](#1.3%E3%80%81%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95)

[1.4 删除索引](#1.3%20%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95)

[1.5 查看索引](#1.5%20%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95)

[二、MySQL8.0索引新特性](#%E4%BA%8C%E3%80%81MySQL8.0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7)

[2.1 支持降序索引](#2.1%20%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95)

[2.2 隐藏索引](#2.2%20%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95)

[三、索引的设计原则](#%E4%B8%89%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99)

[3.1 适合创建索引的情况](#3.1%20%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95)

[3.1.1 简洁版](#3.1.1%20%E7%AE%80%E6%B4%81%E7%89%88%C2%A0) 

[3.1.2 详细版](#3.1.2%20%E8%AF%A6%E7%BB%86%E7%89%88)

[3.2 不适合创建索引的情况](#3.3%20%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95)

--

## 一、索引的分类与使用

### 1.1 索引的分类

MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。

从**功能逻辑**上说，索引主要有 4 种，分别是**普通索引、唯一索引、主键索引、全文索引**。

按照**物理实现方式**，索引可以分为 2 种：**聚簇索引和非聚簇索引**。

按照作用**字段个数**进行划分，分成**单列索引和联合索引**。

#### **1.1.1. 普通索引**

在创建普通索引时，**不附加任何限制条件**，只是用于提高查询效率。这类索引可以创建在**任何数据类型**中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。

建立索引以后，可以通过索引进行查询。例如，在表student 的字段 name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。

#### **1.1.2. 唯一索引**

使用UNIQUE参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该**索引的值**必须是**唯一**的，但**允许有多个空值**。在一张数据表里可以有多个唯一索引。

例如，在表student的字段emai1中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引可以更快速地确定某条记录。

**唯一约束和唯一索引的区别：**

-   唯一约束和唯一索引，都可以实现列数据的唯一，列值可以有null。
-   **唯一约束自动创建不独立的唯一索引：**创建唯一约束，会自动创建一个同名的唯一索引，该索引**不能单独删除**，删除约束会自动删除索引。唯一约束是通过唯一索引来实现数据的唯一。
-   创建一个唯一索引，这个索引就是独立，可以单独删除。
-   如果一个列上想有约束和索引，且两者可以单独的删除。可以先建唯一索引，再建同名的唯一约束。
-   **外键必须是唯一约束：**如果表的一个字段，要作为另外一个表的外键，这个字段必须有唯一约束（或是主键），如果只是有唯一索引，就会报错。

#### **1.1.3. 主键索引（唯一非空）**

主键索引就是一种特殊的唯一性索引，在**唯一**索引的基础上增加了**不为空**的约束，也就是NOTNULL+UNIQUE，**一张表最多只有一个主键索引**。

这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。

#### **1.1.4. 单列索引**

在表中的**单个字段**上创建**索引**。单列索引**只根据该字段**进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。

#### **1.1.5. 多列(组合、联合)索引**

多列索引是在表的**多个字段组合**上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、name和gender上建立一个多列索引idx\_id\_name\_gender，只有在查询条件中使用了字段id时该索引才会被使用。使用组合索引时**遵循最左前缀集合**。

> **最左前缀集合：**指的是由多个列组成的联合索引，在查询时只会使用最左边的几个列进行索引查询。具体来说，如果一个联合索引包含了列A、B和C三列，那么MySQL只能使用A、A+B或者A+B+C这三种方式进行查询。而不能仅仅使用B或者C列进行查询。

#### **1.1.6. 全文索引**

全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用**\[分词术\]**等多种算法智能**分析**出文本文字中**关键词的频率和重要性**，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常**适合大型数据集**，对于小的数据集，它的用处比较小。

使用**参数FULLTEXT**可以设置索引为全文索引。在定义索引的列上支持值的全文查找，**允许**在这些索引列中插入**重复值和空值**。全文索引只能创建在CHAR、VARCHAR或TEXT类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表student的字段information是TEXT类型该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度.

全文索引典型的有两种类型:**自然语言的全文索引和布尔全文索引**

自然语言搜索引擎将计算每一个文档对象和查询的**相关度**。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中**出现次数越少**的词语，匹配时的**相关度就越高**。相反，非常常见的单词将不会被搜索，如果一个词语的在超过50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。

MySQL数据库从3.23.23版开始支持全文索引，但MySQL5.6.4以前只有Myisam支持，5.6.4版本以后innodb才支持，但是官方版本不支持中文分词，需要第三方分词插件。在**5.7.6版本**，MySQL内置了**ngram全文解析器**，用来**支持亚洲语种的分词**。测试或使用全文索引时，要先看一下自己的MySQL版本、存储引擎和数据类型是否支持全文索引。

随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被solrElasticSearch等专门的搜索引擎所替代。

#### **1.1.7. 空间索引（不常用）**

使用**参数SPATIAL**可以设置索引为空间索引。空间索引只能建立在**空间数据类型**上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEOMETRY、POINT、LINESTRING和POLYGON等。目前**只有MyISAM存储引擎支持空间检索**，而且**索引的字段不能为空值**。对于初学者来说，这类索引**很少会用到**。

**小结：不同的存储引擎支持的索引类型也不一样**

InnoDB：支持B-tree、Full-text等索引，不支持Hash索引；MyISAM：支持B-tree、Full-text等索引，不支持Hash索引；Memory：支持B-tree、Hash等索引，不支持Full-text索引NDB：支持Hash索引，不支持B-tree、Full-text等索引；Archive：不支持B-tree、Hash、Full-text等索引；

### 1.2 创建表的时候创建索引

> MySQL支持多种方法在单个或多个列上创建索引: 在**创建表**的定义语句 **CREATE TABLE** 中指定索引列，使用**ALTER TABLE**语句在**存在的表上创建索引**，或者使用**CREATE INDEX**语句在已**存在的表上添加索引**。

#### 1.2.1 约束字段会隐式自动创建索引

使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义**主键约束、外键约束或者唯一性约束**而不论创建哪种约束，在定义**约束的同时相当于**在指定列上**创建**了一个**索引**。

例如下面部门员工表的主键、唯一字段都**隐式的**创建了索引： 

```sql
CREATE TABLE dept(
    dept_id INT PRIMARY KEY AUTO_INCREMENT,    #主键会自动创建主键索引
    dept_name VARCHAR(20)
);
CREATE TABLE emp(
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    emp_name VARCHAR(20) UNIQUE,    #唯一约束会自动创建唯一索引
    dept_id INT,
    CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)
);
```

#### 1.2.1 显式、创建表的时候创建索引

```sql
CREATE TABLE 表名 [字段名 字段类型]
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [索引名] (字段名 [length]) [ASC |
DESC]
```

> -   **UNIQUE 、FULLTEXT 和SPATIAL 为可选参数**，分别表示唯一索引、全文索引和空间索引；
> -   **INDEX 与KEY 为同义词**，两者的作用相同，用来指定创建索引；
> -   index\_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col\_name为索引名；
> -   col\_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；
> -   **length** 为可选参数，表示**索引的长度**，只有字符串类型的字段才能指定索引长度；
> -   **ASC 或DESC** 指定**升序或者降序的索引值存储**。

**1\. 创建普通索引**

在book表中的year\_publication字段上建立普通索引，SQL语句如下：

```sql
CREATE TABLE book(
    book_id INT ,
    book_name VARCHAR(100),
    authors VARCHAR(100),
    info VARCHAR(100) ,
    comment VARCHAR(100),
    year_publication YEAR,    #被索引的字段
    INDEX(year_publication)    #普通索引，不附加任何限制条件；不指定索引名，那么默认字段名为索引名；
);
```

**2\. 创建唯一索引**

```sql
CREATE TABLE test1(
id INT NOT NULL,    #被索引的字段
name varchar(30) NOT NULL,    
UNIQUE INDEX uk_idx_id(id)    #索引的值必须是唯一的，但允许有空值。
);
```

**3\. 主键索引** 

设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法：

随表一起建索引：

```sql
CREATE TABLE student (
id INT(10) UNSIGNED AUTO_INCREMENT ,    #被索引字段
student_no VARCHAR(200),
student_name VARCHAR(200),
PRIMARY KEY(id)    #主键索引，唯一不为空
);
```

删除主键索引：

```sql
ALTER TABLE student
drop PRIMARY KEY ;
```

修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引

**4\. 创建单列索引**

```sql
CREATE TABLE test2(
id INT NOT NULL,
name CHAR(50) NULL,
INDEX single_idx_name(name(20))
);
```

**5\. 创建组合索引**

在表中的id、name和age字段上建立组合索引 

```sql
CREATE TABLE test3(
id INT(11) NOT NULL,
name CHAR(30) NOT NULL,
age INT(11) NOT NULL,
info VARCHAR(255),
INDEX multi_idx(id,name,age)
);
```

**6\. 创建全文索引**

在表中的info字段上建立全文索引

```sql
CREATE TABLE test4(
id INT NOT NULL,
name CHAR(30) NOT NULL,
age INT NOT NULL,
info VARCHAR(255),
FULLTEXT INDEX futxt_idx_info(info)
) ENGINE=MyISAM;    #在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。
```

给title和body字段添加全文索引

```sql
CREATE TABLE articles (
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
title VARCHAR (200),
body TEXT,
FULLTEXT index (title, body)
) ENGINE = INNODB ;
```

**演示全文索引查询：**

```sql
CREATE TABLE `papers` (
`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
`title` varchar(200) DEFAULT NULL,
`content` text,
PRIMARY KEY (`id`),
FULLTEXT KEY `title` (`title`,`content`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
```

全文索引用match+against方式查询：

```sql
SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);
```

> 回顾like方式的的查询：
> 
> ```sql
> SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;
> ```

> **注意点**
> 
> 1\. 使用全文索引前，搞清楚版本支持情况；  
> 2\. 全文索引比 like + % 快 N 倍，但是可能存在精度问题；  
> 3\. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。

### 1.3 在已经存在的表上创建索引

在已经存在的表中创建索引可以使用**ALTER TABLE**语句或者**CREATE INDEX**语句。

**方法一：** 使用**ALTER TABLE**语句创建索引 ALTER TABLE语句创建索引的基本语法如下：

```sql
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],...) [ASC | DESC]
```

**方法二（推荐）：**使用**CREATE INDEX**创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX**被映射到一个ALTER TABLE语句上**，基本语法结构为：

```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC]
```

> **示例：**在学生表上，给年纪、班级字段创建联合索引
> 
> ```sql
> CREATE INDEX idx_age_classid ON student(age,classId);
> ```

### 1.4 删除索引

1\. 使用ALTER TABLE删除索引 ALTER TABLE删除索引的基本语法格式如下：

```sql
ALTER TABLE table_name DROP INDEX index_name;
```

 2. 使用DROP INDEX语句删除索引 DROP INDEX删除索引的基本语法格式如下：

```sql
DROP INDEX index_name ON table_name;
```

> **提示**
> 
> 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成  
> 索引的所有列都被删除，则整个索引将被删除。

### 1.5 查看索引

```sql
SHOW INDEX FROM student;
```

 只有主键索引：![](https://i-blog.csdnimg.cn/blog_migrate/1470724cdb0bcf6f7bf57e8e23644998.png)

> 创建联合索引并查看：
> 
> ```sql
> CREATE INDEX idx_age_classid_name ON student(age,classId,name);
> SHOW INDEX FROM student;
> ```
> 
> ![](https://i-blog.csdnimg.cn/blog_migrate/4806923988d83dff5157c2b08ff17f2f.png)

## 二、MySQL8.0索引新特性

### 2.1 支持降序索引

创建降序的外键索引：

```sql
CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
```

在MySQL 8.0版本中查看数据表ts1的结构，可以发现是降序，结果如下：

![](https://i-blog.csdnimg.cn/blog_migrate/92843efebb5be6d887332161f46a40c1.png)

>  在MySQL 5.7版本中查看数据表ts1的结构，索引仍然是默认的升序，结果如下：
> 
> ![](https://i-blog.csdnimg.cn/blog_migrate/b6926536e38a0169fd2f39a9392e3e16.png)

### 2.2 隐藏索引

> 在**MySQL 5.7版本及之前**，只能通过**显式**的方式**删除索引**。此时，如果发现**删除索引后出现错误**，又**只能**通过**显式创建索引**的方式**将删除的索引创建回来**。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。

将待删除的索引设置为隐藏索引，mysql确认删除索引后不会出错后再彻底删除索引。

从MySQL 8.x开始支持**隐藏索引**（invisible indexes） ，只需要将**待删除的索引设置为隐藏索引**，使**查询优化器不再使用这个索引**（即使使用force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何影响，就可以**彻底删除索引**。这种通过**先将索引设置为隐藏索引，再删除索引**的方式就是软删除。

```sql
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

## 三、索引的设计原则

### 3.1 适合创建索引的情况

#### 3.1.1 简洁版 

1.  唯一特性的字段，适合创建索引
2.  频繁作为where条件的字段，适合创建索引
3.  经常分组或排序查询的字段，适合创建索引
4.  增改语句的查询条件字段，适合创建索引
5.  DISTINCT字段，适合创建索引
6.  多表连接时，连接表数量别超过3张，where字段和连接字段，适合创建索引
7.  数据范围越小的字段，越适合创建索引
8.  很长的varchar字段，适合创建前缀索引
9.  区分度高的字段，适合作为索引
10.  联合索引，将频繁查询的列放到左侧
11.  多个字段都要创建索引时，联合索引优于单值索引
12.  单张表索引数建议别超过6个

#### 3.1.2 详细版

**1\. 唯一特性的字段，适合创建索引**

业务上具有唯一特性（例如唯一约束、主键约束）的字段，**即使是组合字段**，也必须建成唯一索引。（来源：Alibaba）

说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但**提高查找速度**是明显的。

**2\. 频繁作为where条件的字段，适合创建索引**

某个字段在SELECT语句的 **WHERE 条件**中经常被使用到，那么就需要给这个字段创建索引了。尤其是在**数据量大**的情况下，创建普通索引就可以**大幅提升**数据查询的**效率**。

**3\. 经常分组或排序查询的字段，适合创建索引**

本身索引就已经排好序了，而且B+树叶节点一起组成双向链表，很适合范围查询。很适合建立索引。

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 **GROUP BY** 对数据进行分组查询，或者使用 **ORDER BY** 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。

如果待**排序的列有多个**，那么可以在这些列上建立**联合索引**。

**4\. 增改语句的查询条件字段，适合创建索引**

 UPDATE、DELETE 的 WHERE 条件列。对数据按照某个条件进行**查询后**再进行 **UPDATE 或 DELETE** 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。

**5.DISTINCT字段，适合创建索引**

有时候我们需要对某个字段进行**去重**，使用 **DISTINCT**，那么对这个字段创建索引，也会提升查询效率。因为索引会对数据按照某种顺序进行排序，**排序后再去重**会快很多。

```sql
SELECT DISTINCT 字段列表 FROM 表名;
```

**6\. 多表连接时，连接表数量别超过3张，where字段和连接字段适合创建索引**

首先， **连接表的数量**尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。

其次， 对 **WHERE 条件创建索引**，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。

最后， 对用于**连接的字段创建索引**，并且该字段在多张表中的类型必须一致。比如 course\_id 在student\_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

**7\. 数据范围越小的字段，越适合创建索引**

我们这里所说的类型大小指的就是该类型表示的**数据范围的大小**。

我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，**尽量让索引列使用较小的类型**，比如我们**能使用INT就不要使用BIGINT**，能使用MEDIUMINT就不要使用INT。这是因为:

**数据类型越小，**在查询时进行的**比较操作越快**

数据类型越小，索引占用的**存储空间就越少**，在一个数据页内就可以放下更多的记录，从而**减少磁盘I/0**带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的**主键**来说**更加适用**，因为不仅是聚簇索引中会存储主键值，其他所有的**二级索引**的节点处都会**存储一份记录的主键值**，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。

 **8\. 很长的varchar字段，适合创建前缀索引**

假设我们的**字符串很长**，那存储一个**字符串**就需要**占用**很大的**存储空间**。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题:

B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大；

如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。我们可以通过**截取字符串区分度高的前缀子串建立索引**，这个就叫**前缀索引**。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了符串的比较时间，还大体能解决排序的问题。

**计算区分度度：**

```sql
count(distinct left(列名, 索引长度))/count(*)
```

left()函数用于取字符串前缀。 

> **案例：**
> 
> 创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引
> 
> ```sql
> create table shop(address varchar(120) not null);
> alter table shop add index(address(12));
> ```
> 
> 问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。
> 
> **计算不同的长度的区分性，通过区分度判断**  
> 完整字段在全部数据中的选择度：
> 
> ```sql
> select count(distinct address) / count(*) from shop;
> ```
> 
> 通过不同长度去计算，与全表的选择性对比： 
> 
> ```sql
> count(distinct left(列名, 索引长度))/count(*)
> ```

> **索引列前缀对排序的影响：**Alibaba《Java开发手册》
> 
> 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，**根据实际文本区分度决定索引长度**。
> 
> 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90% 以上，可以使用 count(distinct left(列名, 索引长度))/count(\*)的区分度来确定。

**9\. 区分度高的字段，适合作为索引**

**10\. 联合索引，将频繁查询的列放到左侧**

这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。

**11\. 多个字段都要创建索引时，联合索引优于单值索引**

**12.单张表索引数建议别超过6个**

在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因:

**\-** 每个索引都需要**占用磁盘空间**，索引越多，需要的磁盘空间就越大

**\-** 索引会**影响INSERT、DELETE、UPDATE等语句的性能**，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。

**\-** 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会**增加MySQL优化器生成执行计划时间**，降低查询性能.

### 3.2 不适合创建索引的情况

**1\. 在where中使用不到的字段，不要设置索引**

**2\. 数据量小的表，不要设置索引**

在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。

**3\. 有大量重复数据的列上，不要设置索引**

当数据重复度大，比如**高于 10%** 的时候，也不需要对这个字段使用索引。 

例如100万数据量的学生表，只有10个男生，其他都是女生，性别字段就别设置索引。  

**4\. 经常更新的表，不要创建过多索引**

第一层含义:**频繁更新的字段**不一定要创建索引。因为**更新数据**的时候，也**需要更新索引**，如果索引太多，在更新索引的时候也会造成**负担**，从而影响效率。

第二层含义:避免对**经常更新的表**创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会**降低更新表的速度**。 

**5\. 不建议用无序的值作为索引**

例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。

**6\. 删除很少使用的索引**

表中的数据被大量更新，或者数据的使用方式被改变后，原有的**一些索引**可能**不再需要**。数据库管理员应当定期找出这些索引，将它们**删除**，从而**减少索引对更新操作的影响**。

**7\. 不要定义冗余或重复的索引**

冗余索引示例：个人信息表，**联合索引最左边字段不需再创建索引**

```sql
CREATE TABLE person_info(
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
    KEY idx_name (name(10))
);
```

我们知道，通过idx\_name\_birthday\_phone\_number **联合索引**就可以对**name 列进行快速搜索**，再创建一个**专门针对name 列的索引就算是一个冗余索引**，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。

重复索引示例：

另一种情况，我们可能会对**某个列重复建立索引**，比方说这样：

```sql
CREATE TABLE repeat_index_demo (
    col1 INT PRIMARY KEY,
    col2 INT,
    UNIQUE uk_idx_c1 (col1),
    INDEX idx_c1 (col1)
);
```

我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是**主键本身就会生成聚簇索引**，所以定义的唯一索引和普通索引是重复的，这种情况要避免。